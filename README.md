## recipe-front-with-TanstackRouter

このレポジトリは以前作ったレシピアプリのフロントの部分をReactjsとTanstack Routerの組み合わせで開発し直したものになります。ですが、実際にNextjsで開発してみると自分が開発しているアプリにNextjsはオーバスペックだと感じました。Next.jsに魅力を感じていたのは以下の通りです。

1. Nextjsを採用してSSR化することで、初期表示速度が速くなる。
2. 画像最適化を行ってくれるImageコンポーネントの存在により、画像の表示速度が高速になる
3. ファイルベースのルーティングを行える

1. の点に関して、そもそも私が開発するレシピアプリはページネーションを採用しており、最大でも12個のレシピしか取得されませんし、加えて、コード分割も行って、ユーザーの読み込み時間が減るようにしており、SSR化が必要なほど初期表示に時間がかかるケースはほとんどないと感じました。

2. の点に関しては、最初は魅力的に感じていたのですが、そもそも画像をPOSTする前に、画像を最適化したり(browser-image-compressionといったライブラリを使用するなどして)、あるいはサーバー側(Ruby on Railsのライブラリを使用して)で最適化すれば済む問題だと感じました。つまり、Imageコンポーネントを使わずとも画像を最適化する方法はあるので、Nextjsを採用する決め手にならないと考えるようになりました。ちなみに、この画像の最適化に関しては、[browser-image-compression](https://www.npmjs.com/package/browser-image-compression)というライブラリを使用しました。

3. の点に関しても、Tanstack Routerを採用することで、Nextjsのようにファイルベースのルーティングができるので、Nextjsを採用する決め手にはならないと感じました。

もちろん、Next.js自体は素晴らしいフレームワークではあるのですが、アップデートを続ける内に、パフォーマンスが悪化する可能性もあるのですが、私のレシピアプリにおいては、Next.jsの持つSSR機能やImageコンポーネントによる画像最適化のメリットを享受する必要がなく、ファイルベースのルーティングに関しては、Tanstack Routerの組み合わせで十分に目的を達成できると判断しました。つまり、私のアプリにとってはNext.jsは少々オーバースペックかなと思ったわけです。

使用した主なライブラリ(このレポジトリではフロントエンド側だけ書きます)

1. react
2. react-dom
3. react-hook-form フォームを作成するために使用
4. zod フォームのバリデーションを実装するために使用
5. axios API通信を使用するにあたり使用
6. fuse.js サジェスト機能を実装するために使用
7. js-cookie ログインの際に使用
8. browser-image-compression 画像を最適化するために使用

以下は主なテストツール
8. react-testing-library
9. vitest 
10. msw

工夫した点

1. スケルトンスクリーンの採用
   仮にロード時間に時間がかかっても、心理的に短く感じられるために実装しました

2. コード分割による読み込みの削減
   すぐに必要なコード以外は後から読み込ませることによって、初期表示にかかる時間の削減できるので、実装しました

3. ページネーション
   大量のレシピがある場合、全部の投稿を取得しようとすると、時間がかかるので、実装しました。

4. レシピのサジェスト機能の追加
   マイリストに追加するのを忘れたレシピがあっても、サジェスト機能を用いることで、大体のレシピ名さえ覚えていれば、目的のレシピをすぐ見つけられると思い、この機能を実装しました。

## サジェスト候補を出す機能を実装する上で迷ったこと

サジェスト候補を出すにあたって悩んだことがありました。それは、Fuse.jsを使ったあいまい検索にするか、Trie構造などを使った前方一致検索にした方がいいか、どちらが良いのかということです。

　理由として、Fuse.jsを使ったあいまい検索は、処理速度がどうしても遅くなることにあります。もちろん、サジェスト候補を表示するのにかかる時間はユーザーのデバイスのスペックに依存するのですが、私のMacBook Air（M2チップ、16GBメモリ、512GBストレージ）で試したところ、10,000件のダミーデータを使用した場合、検索欄に1文字入力するごとに平均して20msから30msほどの時間がかかりました。一方、Trie構造を使った前方一致検索では、同じ条件下で5msから10msほどで処理が完了しました。特に、Trie構造の場合、その構造上、検索欄に入力する文字数が増えるほど、候補が絞られていき、処理時間はさらに短縮される傾向があります。

　このような結果から、多くのデータを扱う場合、処理速度の点であいまい検索よりも前方一致検索の方が望ましいと感じました。また、filterメソッドを使っても前方一致検索を実現できますが、この方法では配列全体を確認するため、データ量が多いと処理時間が長くなる可能性があります。一方で、Trie構造ではユーザーが入力する文字が増えるほど、処理が効率化されるため、扱うデータの量によってはTrie構造を使うことが望ましいかもしれません。

　現在はデータ量が少ないため、あいまい検索の柔軟性を重視してFuse.jsを使っています。とはいえ、今後もしデータ量が大きいアプリを扱う場合には、全てをJavaScriptの処理で行うには限界があるでしょう。そのため、その部分はサーバー側に任せたり、Elasticsearchのようなサービスを活用する必要があると思いました。